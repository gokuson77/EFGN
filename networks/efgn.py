import torchimport torch.nn as nnclass efmodule(nn.Module):    def __init__(self, inch, outch, k_size,  d_size, stride):        super(efmodule, self).__init__()        hidch = outch//2        self.cov1 = nn.Sequential(            nn.Conv2d(inch, hidch, k_size, stride, k_size//2),            nn.ReLU(True),        )        # self.cov2 = nn.Conv2d(hidch, hidch, d_size, stride, d_size//2, groups=hidch)        self.cov2 = nn.Sequential(            nn.Conv2d(hidch, hidch, d_size, stride, d_size//2, groups=hidch),            nn.ReLU(True),        )        self.cov3 = nn.Sequential(            nn.Conv2d(2*inch, outch, k_size, stride, k_size // 2),            nn.ReLU(True),        )        # self.cov2 = nn.Conv2d(hidch, hidch, d_size, stride, d_size//2, groups=hidch)        self.cov4 = nn.Sequential(            nn.Conv2d(inch, outch, d_size, stride, d_size // 2, groups=inch),            nn.ReLU(True),        )    def forward(self, x):        x1 = self.cov1(x)        x2 = self.cov2(x1)        interv = torch.cat([x1, x2], dim=1)        interv = torch.cat([x, interv], dim=1)        x3 =self.cov3(interv)        x4 = self.cov4(x3)        out = torch.cat([x3, x4], dim=1)        out = torch.cat([out, interv], dim=1)        return outclass efblock(nn.Module):    def __init__(self, inch, outch, k_size,  d_size, stride):        super(efblock, self).__init__()        self.block = nn.Sequential(            efmodule(inch, outch, k_size,  d_size, stride),            # nn.ReLU(True),            # efmodule(2*inch, 2*outch, k_size,  d_size, stride),            # nn.ReLU(True),            nn.Conv2d(4 * outch, outch, 1, 1),            efmodule(inch, outch, k_size, d_size, stride),            nn.Conv2d(4 * outch, outch, 1, 1),        )    def forward(self, x):        return x+self.block(x)class efnet(nn.Module):    def __init__(self, nf, scale):        super(efnet, self).__init__()        self.scale = scale        self.head = nn.Sequential(            nn.Conv2d(3, nf, 3, 1, 1),            nn.ReLU(True),            nn.Conv2d(nf, nf, 3, 1, 1),            nn.ReLU(True),        )        self.block1 = efblock(nf, nf, 3, 3, 1)        self.block2 = efblock(nf, nf, 3, 3, 1)        self.block3 = efblock(nf, nf, 3, 3, 1)        self.block4 = efblock(nf, nf, 3, 3, 1)        self.cat = nn.Sequential(            nn.Conv2d(nf*4, nf, 1, 1),            nn.ReLU(True),        )        if scale == 2:            self.upscale = nn.Sequential(                nn.Conv2d(nf, 2 * 2 * 3, 3, 1, 1),                nn.PixelShuffle(2),            )        elif scale == 3:            self.upscale = nn.Sequential(                nn.Conv2d(nf, 3 * 3 * 3, 3, 1, 1),                nn.PixelShuffle(3),            )        # elif scale == 4:        #     self.upscale = nn.Sequential(        #         # nn.Conv2d(nf, 3, 3, 1, 1),        #         # nn.Conv2d(3, 2 * 2 * 3, 3, 1, 1),        #         # nn.PixelShuffle(2),        #         nn.Conv2d(nf, 4 * 4 * 3, 3, 1, 1),        #         nn.PixelShuffle(4),        #     )        elif scale == 4:            self.upscale = nn.Sequential(                nn.Conv2d(nf, 4 * 4 * 3, 3, 1, 1),                nn.PixelShuffle(4),            )    def forward(self, x):        inter_res = nn.functional.interpolate(x, scale_factor=self.scale, mode='bicubic', align_corners=False)        fea = self.head(x)        x1 = self.block1(fea)        x2 = self.block2(x1)        x3 = self.block3(x2)        x4 = self.block4(x3)        unit = self.cat(torch.cat([x1, x2, x3, x4], dim=1))        x = self.upscale(unit)        out = torch.add(x, inter_res)        return out